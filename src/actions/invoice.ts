'use server'

import { createClient, createServiceClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { requireAdmin } from '@/lib/auth/guards'
import { generateInvoicePdf, fetchImageAsBase64, InvoiceItem } from '@/lib/pdf/generateInvoice'
import { format } from 'date-fns'

// ============================================================
// Invoice Types (until types are regenerated from Supabase)
// ============================================================

export type InvoiceStatus = 'DRAFT' | 'SENT' | 'PAID' | 'VOID' | 'OVERDUE'
export type InvoiceCategory = 'RENTAL' | 'WHOLESALE' | 'MANUAL'

export interface InvoiceLineItem {
    id?: string
    item_id?: string | null
    name: string
    description?: string | null
    quantity: number
    unit_price: number
    total: number
}

export interface Invoice {
    id: string
    invoice_number: string
    category: InvoiceCategory
    reservation_id?: string | null
    customer_id?: string | null
    customer_name: string
    customer_email?: string | null
    billing_address?: Record<string, unknown>
    billing_profile_id?: string | null
    currency: string
    total_amount: number
    issue_date: string
    due_date?: string | null
    status: InvoiceStatus
    signed_file_path?: string | null
    notes?: string | null
    created_at: string
    updated_at: string
    items?: InvoiceLineItem[]
}

export interface CreateManualInvoiceInput {
    customer_name: string
    customer_email?: string
    customer_id?: string
    billing_address?: Record<string, unknown>
    billing_profile_id?: string
    items: Omit<InvoiceLineItem, 'id'>[]
    notes?: string
    issue_date?: string
    due_date?: string
}

export interface UpdateInvoiceInput {
    customer_name?: string
    customer_email?: string
    billing_address?: Record<string, unknown>
    billing_profile_id?: string
    notes?: string
    due_date?: string
    items?: Omit<InvoiceLineItem, 'id'>[]
}

// ============================================================
// Invoice CRUD Actions
// ============================================================

/**
 * Creates a manual invoice for services or ad-hoc charges.
 * Does NOT lock inventory (manual invoices are for services).
 */
export async function createManualInvoice(input: CreateManualInvoiceInput) {
    await requireAdmin()
    const supabase = await createClient()

    // Calculate total from items
    const total_amount = input.items.reduce((sum, item) => sum + item.total, 0)

    // Create invoice (invoice_number is auto-generated by trigger)
    const { data: invoice, error: invoiceError } = await supabase
        .from('invoices')
        .insert({
            category: 'MANUAL',
            customer_name: input.customer_name,
            customer_email: input.customer_email || null,
            customer_id: input.customer_id || null,
            billing_address: input.billing_address || {},
            billing_profile_id: input.billing_profile_id || null,
            total_amount,
            issue_date: input.issue_date || new Date().toISOString().split('T')[0],
            due_date: input.due_date || null,
            notes: input.notes || null,
            status: 'DRAFT',
        })
        .select()
        .single()

    if (invoiceError) {
        console.error('Failed to create invoice:', invoiceError)
        return { success: false, error: invoiceError.message, data: null }
    }

    // Insert invoice items
    const itemsToInsert = input.items.map(item => ({
        invoice_id: invoice.id,
        item_id: item.item_id || null,
        name: item.name,
        description: item.description || null,
        quantity: item.quantity,
        unit_price: item.unit_price,
        total: item.total,
    }))

    const { error: itemsError } = await supabase
        .from('invoice_items')
        .insert(itemsToInsert)

    if (itemsError) {
        console.error('Failed to create invoice items:', itemsError)
        // Rollback: delete the invoice
        await supabase.from('invoices').delete().eq('id', invoice.id)
        return { success: false, error: itemsError.message, data: null }
    }

    revalidatePath('/admin/invoices')
    return { success: true, error: null, data: invoice }
}

/**
 * Generates an invoice from an existing reservation.
 * Creates snapshot of items at current prices.
 */
export async function generateInvoiceFromReservation(
    reservationId: string,
    billingProfileId?: string
) {
    await requireAdmin()
    const supabase = await createClient()

    // Fetch reservation with items and customer
    const { data: reservations, error: resError } = await supabase
        .from('reservations')
        .select(`
            *,
            items (id, name, sku, rental_price, description),
            profiles:renter_id (id, full_name, email, company_name, address_line1, address_line2, city_region, country, postcode)
        `)
        .eq('id', reservationId)

    if (resError || !reservations || reservations.length === 0) {
        console.error('Failed to fetch reservation:', resError)
        return { success: false, error: 'Reservation not found', data: null }
    }

    // Get all reservations in the same group
    const primaryReservation = reservations[0]
    const groupId = primaryReservation.group_id

    let allReservations = [primaryReservation]
    if (groupId) {
        const { data: groupRes } = await supabase
            .from('reservations')
            .select(`
                *,
                items (id, name, sku, rental_price, description)
            `)
            .eq('group_id', groupId)

        if (groupRes) {
            allReservations = groupRes
        }
    }

    // Get profile from primary reservation
    const profile = primaryReservation.profiles as {
        id?: string
        full_name?: string
        email?: string
        company_name?: string
        address_line1?: string
        address_line2?: string
        city_region?: string
        country?: string
        postcode?: string
    } | null

    // Build billing address from profile
    const billingAddress: Record<string, unknown> = {}
    if (profile) {
        if (profile.address_line1) billingAddress.line1 = profile.address_line1
        if (profile.address_line2) billingAddress.line2 = profile.address_line2
        if (profile.city_region) billingAddress.city = profile.city_region
        if (profile.country) billingAddress.country = profile.country
        if (profile.postcode) billingAddress.postcode = profile.postcode
    }

    // Calculate items and total
    const invoiceItems: Omit<InvoiceLineItem, 'id'>[] = []
    let totalAmount = 0

    for (const res of allReservations) {
        const item = res.items as { id: string; name: string; sku: string; rental_price: number; description?: string } | null
        if (!item) continue

        const startDate = new Date(res.start_date)
        const endDate = new Date(res.end_date)
        const days = Math.round((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1

        const lineTotal = item.rental_price * days

        invoiceItems.push({
            item_id: item.id,
            name: item.name,
            description: item.sku ? `SKU: ${item.sku} | ${res.start_date} - ${res.end_date}` : `${res.start_date} - ${res.end_date}`,
            quantity: days,
            unit_price: item.rental_price,
            total: lineTotal,
        })

        totalAmount += lineTotal
    }

    // Determine category based on reservation context (default to RENTAL)
    const category: InvoiceCategory = 'RENTAL'

    // Create the invoice
    const { data: invoice, error: createError } = await supabase
        .from('invoices')
        .insert({
            category,
            reservation_id: reservationId,
            customer_id: profile?.id || null,
            customer_name: profile?.full_name || profile?.company_name || 'Customer',
            customer_email: profile?.email || null,
            billing_address: billingAddress,
            billing_profile_id: billingProfileId || null,
            total_amount: totalAmount,
            status: 'DRAFT',
        })
        .select()
        .single()

    if (createError) {
        console.error('Failed to create invoice:', createError)
        return { success: false, error: createError.message, data: null }
    }

    // Insert invoice items
    const itemsToInsert = invoiceItems.map(item => ({
        invoice_id: invoice.id,
        item_id: item.item_id || null,
        name: item.name,
        description: item.description || null,
        quantity: item.quantity,
        unit_price: item.unit_price,
        total: item.total,
    }))

    const { error: itemsError } = await supabase
        .from('invoice_items')
        .insert(itemsToInsert)

    if (itemsError) {
        console.error('Failed to create invoice items:', itemsError)
        await supabase.from('invoices').delete().eq('id', invoice.id)
        return { success: false, error: itemsError.message, data: null }
    }

    revalidatePath('/admin/invoices')
    revalidatePath('/admin/reservations')
    return { success: true, error: null, data: invoice }
}

/**
 * Marks an invoice as paid and syncs the linked reservation status.
 */
export async function markInvoiceAsPaid(invoiceId: string) {
    await requireAdmin()
    const supabase = await createClient()

    // Update invoice status
    const { data: invoice, error: updateError } = await supabase
        .from('invoices')
        .update({ status: 'PAID' })
        .eq('id', invoiceId)
        .select('reservation_id')
        .single()

    if (updateError) {
        console.error('Failed to update invoice:', updateError)
        return { success: false, error: updateError.message }
    }

    // Sync reservation status if linked
    if (invoice?.reservation_id) {
        // First get the group_id from the reservation
        const { data: reservation } = await supabase
            .from('reservations')
            .select('group_id')
            .eq('id', invoice.reservation_id)
            .single()

        if (reservation?.group_id) {
            // Update all reservations in the group
            await supabase
                .from('reservations')
                .update({ status: 'confirmed' }) // confirmed = paid in user flow
                .eq('group_id', reservation.group_id)
        } else {
            // Update single reservation
            await supabase
                .from('reservations')
                .update({ status: 'confirmed' })
                .eq('id', invoice.reservation_id)
        }

        revalidatePath('/admin/reservations')
    }

    revalidatePath('/admin/invoices')
    return { success: true, error: null }
}

/**
 * Updates an invoice (only allowed for DRAFT status).
 */
export async function updateInvoice(invoiceId: string, input: UpdateInvoiceInput) {
    await requireAdmin()
    const supabase = await createClient()

    // Check current status
    const { data: currentInvoice, error: checkError } = await supabase
        .from('invoices')
        .select('status')
        .eq('id', invoiceId)
        .single()

    if (checkError || !currentInvoice) {
        return { success: false, error: 'Invoice not found', data: null }
    }

    if (currentInvoice.status !== 'DRAFT') {
        return { success: false, error: 'Only draft invoices can be edited', data: null }
    }

    // Calculate new total if items are provided
    let total_amount: number | undefined
    if (input.items && input.items.length > 0) {
        total_amount = input.items.reduce((sum, item) => sum + item.total, 0)
    }

    // Update invoice
    const updateData: Record<string, unknown> = {}
    if (input.customer_name) updateData.customer_name = input.customer_name
    if (input.customer_email !== undefined) updateData.customer_email = input.customer_email
    if (input.billing_address) updateData.billing_address = input.billing_address
    if (input.billing_profile_id) updateData.billing_profile_id = input.billing_profile_id
    if (input.notes !== undefined) updateData.notes = input.notes
    if (input.due_date !== undefined) updateData.due_date = input.due_date
    if (total_amount !== undefined) updateData.total_amount = total_amount

    const { data: invoice, error: updateError } = await supabase
        .from('invoices')
        .update(updateData)
        .eq('id', invoiceId)
        .select()
        .single()

    if (updateError) {
        console.error('Failed to update invoice:', updateError)
        return { success: false, error: updateError.message, data: null }
    }

    // Update items if provided
    if (input.items && input.items.length > 0) {
        // Delete existing items
        await supabase.from('invoice_items').delete().eq('invoice_id', invoiceId)

        // Insert new items
        const itemsToInsert = input.items.map(item => ({
            invoice_id: invoiceId,
            item_id: item.item_id || null,
            name: item.name,
            description: item.description || null,
            quantity: item.quantity,
            unit_price: item.unit_price,
            total: item.total,
        }))

        const { error: itemsError } = await supabase
            .from('invoice_items')
            .insert(itemsToInsert)

        if (itemsError) {
            console.error('Failed to update invoice items:', itemsError)
            return { success: false, error: itemsError.message, data: null }
        }
    }

    revalidatePath('/admin/invoices')
    revalidatePath(`/admin/invoices/${invoiceId}`)
    return { success: true, error: null, data: invoice }
}

/**
 * Fetches a single invoice with its items.
 */
export async function getInvoice(invoiceId: string) {
    const supabase = await createClient()

    const { data: invoice, error } = await supabase
        .from('invoices')
        .select(`
            *,
            invoice_items (*),
            billing_profiles (*)
        `)
        .eq('id', invoiceId)
        .single()

    if (error) {
        console.error('Failed to fetch invoice:', error)
        return { data: null, error: error.message }
    }

    return { data: invoice, error: null }
}

/**
 * Fetches all invoices with optional filtering.
 */
export async function getInvoices(filters?: {
    status?: InvoiceStatus | InvoiceStatus[]
    category?: InvoiceCategory
    unpaidOnly?: boolean
}) {
    const supabase = await createClient()

    let query = supabase
        .from('invoices')
        .select(`
            *,
            invoice_items (id, name, quantity),
            reservation:reservations (id, group_id)
        `)
        .order('created_at', { ascending: false })

    if (filters?.unpaidOnly) {
        query = query.in('status', ['DRAFT', 'SENT', 'OVERDUE'])
    } else if (filters?.status) {
        const statuses = Array.isArray(filters.status) ? filters.status : [filters.status]
        query = query.in('status', statuses)
    }

    if (filters?.category) {
        query = query.eq('category', filters.category)
    }

    const { data, error } = await query

    if (error) {
        console.error('Failed to fetch invoices:', error)
        return { data: null, error: error.message }
    }

    return { data, error: null }
}

/**
 * Deletes an invoice (only DRAFT or VOID status).
 */
export async function deleteInvoice(invoiceId: string) {
    await requireAdmin()
    const supabase = await createClient()

    // Check current status
    const { data: invoice, error: checkError } = await supabase
        .from('invoices')
        .select('status')
        .eq('id', invoiceId)
        .single()

    if (checkError || !invoice) {
        return { success: false, error: 'Invoice not found' }
    }

    if (!['DRAFT', 'VOID'].includes(invoice.status)) {
        return { success: false, error: 'Only draft or void invoices can be deleted' }
    }

    // Delete invoice (items will cascade)
    const { error: deleteError } = await supabase
        .from('invoices')
        .delete()
        .eq('id', invoiceId)

    if (deleteError) {
        console.error('Failed to delete invoice:', deleteError)
        return { success: false, error: deleteError.message }
    }

    revalidatePath('/admin/invoices')
    return { success: true, error: null }
}

/**
 * Voids an invoice (marks as VOID instead of deleting).
 */
export async function voidInvoice(invoiceId: string) {
    await requireAdmin()
    const supabase = await createClient()

    const { error } = await supabase
        .from('invoices')
        .update({ status: 'VOID' })
        .eq('id', invoiceId)

    if (error) {
        console.error('Failed to void invoice:', error)
        return { success: false, error: error.message }
    }

    revalidatePath('/admin/invoices')
    return { success: true, error: null }
}

/**
 * Updates invoice status (e.g., DRAFT -> SENT).
 */
export async function updateInvoiceStatus(invoiceId: string, status: InvoiceStatus) {
    await requireAdmin()
    const supabase = await createClient()

    const { error } = await supabase
        .from('invoices')
        .update({ status })
        .eq('id', invoiceId)

    if (error) {
        console.error('Failed to update invoice status:', error)
        return { success: false, error: error.message }
    }

    revalidatePath('/admin/invoices')
    return { success: true, error: null }
}

/**
 * Generates regular PDF for download.
 * Returns base64 string.
 */
export async function downloadInvoicePdf(invoiceId: string) {
    await requireAdmin()
    const supabase = await createClient()

    // 1. Fetch Invoice
    const { data: invoice, error } = await supabase
        .from('invoices')
        .select(`
            *,
            invoice_items (*),
            billing_profiles (*)
        `)
        .eq('id', invoiceId)
        .single()

    if (error || !invoice) {
        return { success: false, error: 'Invoice not found' }
    }

    // 2. Prepare items with images
    const serviceClient = createServiceClient()
    const invoiceItems: InvoiceItem[] = []

    for (const item of invoice.invoice_items) {
        let imageBase64: string | undefined

        // If it was linked to a rental item, try to fetch its image
        if (item.item_id) {
            const { data: rentalItem } = await supabase
                .from('items')
                .select('image_paths')
                .eq('id', item.item_id)
                .single()

            if (rentalItem?.image_paths?.[0]) {
                try {
                    imageBase64 = await fetchImageAsBase64(serviceClient, 'rental_items', rentalItem.image_paths[0])
                } catch (e) {
                    console.warn(`Failed to fetch image for item ${item.item_id}`)
                }
            }
        }

        invoiceItems.push({
            name: item.name,
            sku: '', // TODO: Fetch SKU if needed
            rentalPrice: item.unit_price,
            days: item.quantity,
            startDate: '', // Not stored on invoice_items directly unless we parse description
            endDate: '',
            imageBase64
        })
    }

    // 3. Prepare Billing Profile
    const billingProfile = invoice.billing_profiles || {
        company_header: "Ivy's Rental",
        contact_email: 'contact@ivysrental.com',
        bank_info: '',
    }

    // 4. Generate PDF
    try {
        const buffer = await generateInvoicePdf({
            invoiceId: invoice.invoice_number,
            date: format(new Date(invoice.issue_date), 'MMM dd, yyyy'),
            customerName: invoice.customer_name,
            customerEmail: invoice.customer_email || '',
            // Handle address JSONB safely
            customerAddress: invoice.billing_address ? Object.values(invoice.billing_address).map(v => String(v)) : [],
            items: invoiceItems,
            companyName: billingProfile.company_header,
            companyEmail: billingProfile.contact_email,
            bankInfo: billingProfile.bank_info,
            notes: invoice.notes || undefined,
        })

        return { success: true, data: buffer.toString('base64') }
    } catch (e) {
        console.error('PDF Generation failed:', e)
        return { success: false, error: 'Failed to generate PDF' }
    }
}
